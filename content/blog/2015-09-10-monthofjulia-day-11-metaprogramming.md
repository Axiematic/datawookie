---
author: Andrew B. Collier
date: 2015-09-10T14:00:04Z
tags: ["Julia", "#MonthOfJulia"]
title: 'MonthOfJulia Day 11: Metaprogramming'
---

<!--more-->

<img src="/img/2015/09/Julia-Logo-Metaprogramming.png" >

Metaprogramming in Julia is a big topic and it's covered extensively in both the [official documentation](http://julia.readthedocs.org/en/latest/manual/metaprogramming/) as well as in the [Introducing Julia](https://en.wikibooks.org/wiki/Introducing_Julia/Metaprogramming) wikibook. The idea behind metaprogramming is to write code which itself will either generate or change other code. There are two main features of the language which support this idea:

* code representation (expressions and symbols) and 
* macros.

## Code Representation

A symbol (data type `Symbol`) represents an unevaluated chunk of code. As such, symbols are a means to refer to a variable (or expression) itself rather than the value it contains.

{{< highlight julia >}}
julia> n = 5 # Assign to variable n.
5
julia> n # Refer to contents of variable n.
5
julia> typeof(n)
Int64
julia> :n # Refer to variable n itself using quote operator.
:n
julia> typeof(:n)
Symbol
julia> eval(:n)
5
julia> E = :(2x + y) # Unevaluated expression is also a symbol.
:(2x + y)
julia> typeof(E)
Expr
{{< /highlight >}}

The quote operator, `:`, prevents the evaluation of its argument.

Expressions are made up of three parts: the operation (`head`), the arguments to that operation (`args`) and finally the return type from the expression (`typ`).

{{< highlight julia >}}
julia> names(E)
3-element Array{Symbol,1}:
 :head
 :args
 :typ
julia> E.head
:call
julia> E.args
3-element Array{Any,1}:
 :+
 :(2x)
 :y
julia> E.typ
Any
{{< /highlight >}}

We can evaluate an expression using `eval()`. Not only does `eval()` return the result of the evaluated expression but it also applies any side effects from the expression (for example, variable assignment).

{{< highlight julia >}}
julia> x = 3; y = 5; eval(E)
11
julia> eval(:(x = 4))
4
julia> eval(E)
13
{{< /highlight >}}

No real surprises there. But the true potential of all this lies in the fact that the code itself has an internal representation which can be manipulated. For example, we could change the arguments of the expression created above.

{{< highlight julia >}}
julia> E.args[3] = :(3y) # 2x + y becomes 2x + 3y
:(3y)
julia> E
:(2x + 3y)
julia> eval(E)
21
{{< /highlight >}}

That still seems a little tame. What about manipulating a function?

{{< highlight julia >}}
julia> F = :(x -> x^2)
:(x->begin # none, line 1:
    x^2
end)
julia> eval(F)(2) # Evaluate x -> x^2 for x = 2
4
julia> F.args[2].args[2].args[3] = 3 # Change function to x -> x^3
3
julia> eval(F)(2) # Evaluate x -> x^3 for x = 2
8
{{< /highlight >}}

## Macros

Macros are a little like functions in that they accept arguments and return a result. However they are different because they are evaluated at parse time and return an unevaluated expression.

{{< highlight julia >}}
julia> macro square(x)
           :($x * $x)
       end
julia> @square(5)
25
julia> @square 5
25
julia> macroexpand(:(@square(x)))
:(x * x)
julia> macroexpand(:(@square(5)))
:(5 * 5)
julia> macroexpand(:(@square(x+2)))
:((x + 2) * (x + 2))
{{< /highlight >}}

`macroexpand()` is used to look at the code generated by the macro. Note that parentheses were automatically inserted to ensure the correct order of operations.

Julia has a plethora of predefined macros which do things like return the execution time for an expression (`@time`), apply an assertion (`@assert`), test approximate equality (`@test_approx_eq`) and execute code only in a UNIX environment (`@unix_only`).

The fact that one can use code to build and edit other code made me start thinking about [self-replicating machines](https://en.wikipedia.org/wiki/Self-replicating_machine), [self-reconfiguring modular robots](https://en.wikipedia.org/wiki/Self-reconfiguring_modular_robot), [grey goo](https://en.wikipedia.org/wiki/Grey_goo) and [utility fog](https://en.wikipedia.org/wiki/Utility_fog). If we can do it in software, why not in hardware too? More evidence of my tinkering with metaprogramming in Julia can be found on [github](https://github.com/DataWookie/MonthOfJulia). No self-reconfiguring modular robots though, I'm afraid.

<iframe width="560" height="315" src="https://www.youtube.com/embed/EpNeNCGmyZE" frameborder="0" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/KAN8zbM659o" frameborder="0" allowfullscreen></iframe>